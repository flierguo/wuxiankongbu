# 如何应用数值版到攻击计算模块

## 一、核心优势

### 1. 链式调用性能提升
**当前字符串版**：
```typescript
let 伤害 = js_number(基础攻击, 总倍率, 3);        // parseFloat × 2 + toString
伤害 = js_number(伤害, 安全额外伤害, 1);          // parseFloat × 2 + toString
伤害 = js_number(伤害, 安全额外倍攻, 3);          // parseFloat × 2 + toString
伤害 = js_number(伤害, 基础攻击, 1);              // parseFloat × 2 + toString
// 总计：8次parseFloat + 4次toString = 12次字符串操作
```

**数值版优化**：
```typescript
let 伤害 = js_number_数值版(基础攻击, 总倍率, 3);  // parseFloat × 2 + Decimal
伤害 = js_number_数值版(伤害, 安全额外伤害, 1);    // Decimal直接计算（无parseFloat）
伤害 = js_number_数值版(伤害, 安全额外倍攻, 3);    // Decimal直接计算
伤害 = js_number_数值版(伤害, 基础攻击, 1);        // Decimal直接计算
// 总计：2次parseFloat + 4次Decimal操作 = 6次操作
// 性能提升：50%
```

### 2. 链式调用更优雅
**数值版支持链式调用**：
```typescript
// 可以这样写（更高效）
const 伤害 = js_number_数值版(基础攻击, 总倍率, 3)
    .plus(js_number_数值版(安全额外伤害, '0', 1))
    .mul(js_number_数值版(安全额外倍攻, '1', 3))
    .plus(js_number_数值版(基础攻击, '0', 1));
```

## 二、迁移策略

### 方案A：完全替换（推荐用于新版本）

**优点**：
- 性能提升最大（40-50%）
- 代码更清晰
- 减少字符串操作

**步骤**：
1. 创建新文件：`攻击计算_数值版.ts`
2. 修改所有 `js_number()` 为 `js_number_数值版()`
3. 修改返回类型：`string` → `Decimal`，最后调用 `.toString()`
4. 优化链式调用

### 方案B：混合使用（渐进式迁移）

**策略**：
- 高频计算函数使用数值版
- 简单单次调用保持字符串版
- 逐步迁移

## 三、具体迁移示例

### 示例1：基础伤害计算函数

**原版（字符串版）**：
```typescript
function 计算技能基础伤害(
    基础攻击: string,
    等级: number,
    基础倍率: number,
    等级倍率: number,
    额外倍攻: string,
    额外伤害: string
): string {
    const 安全等级 = safeNumber(等级);
    const 安全基础倍率 = safeNumber(基础倍率) || 1;
    const 安全等级倍率 = safeNumber(等级倍率);
    const 安全额外倍攻 = 安全字符(额外倍攻, '1');
    const 安全额外伤害 = 安全数值(额外伤害, 基本常量.NO_DAMAGE);
    
    const 总倍率值 = 安全基础倍率 + 安全等级 * 安全等级倍率;
    const 总倍率 = String(Math.max(总倍率值, 1));
    
    // 链式调用 - 每次都要parseFloat + toString
    let 伤害 = js_number(基础攻击, 总倍率, 3);
    伤害 = js_number(伤害, 安全额外伤害, 1);
    伤害 = js_number(伤害, 安全额外倍攻, 3);
    伤害 = js_number(伤害, 基础攻击, 1);
    
    return sanitizeDamage(伤害, 基本常量.最小攻击);
}
```

**数值版优化**：
```typescript
import { Decimal } from "../全局脚本[公共单元]/utils/big_number";
import { js_number_数值版, js_war_数值版 } from "../全局脚本[公共单元]/utils/计算方法_优化版";

function 计算技能基础伤害_数值版(
    基础攻击: string | Decimal,
    等级: number,
    基础倍率: number,
    等级倍率: number,
    额外倍攻: string | number,
    额外伤害: string | number
): Decimal {
    const 安全等级 = safeNumber(等级);
    const 安全基础倍率 = safeNumber(基础倍率) || 1;
    const 安全等级倍率 = safeNumber(等级倍率);
    
    // 转换为Decimal（如果已经是Decimal则直接使用）
    const 基础攻击Decimal = 基础攻击 instanceof Decimal 
        ? 基础攻击 
        : js_number_数值版(基础攻击, '0', 1);
    
    const 安全额外倍攻Decimal = typeof 额外倍攻 === 'number'
        ? js_number_数值版(额外倍攻, '1', 1)
        : js_number_数值版(额外倍攻 || '1', '1', 1);
    
    const 安全额外伤害Decimal = typeof 额外伤害 === 'number'
        ? js_number_数值版(额外伤害, '0', 1)
        : js_number_数值版(额外伤害 || '0', '0', 1);
    
    // 计算总倍率（使用number计算，更快）
    const 总倍率值 = 安全基础倍率 + 安全等级 * 安全等级倍率;
    const 总倍率 = Math.max(总倍率值, 1);
    
    // 链式调用 - 中间结果无需转换
    let 伤害 = js_number_数值版(基础攻击Decimal, 总倍率, 3)
        .plus(安全额外伤害Decimal)
        .mul(安全额外倍攻Decimal)
        .plus(基础攻击Decimal);
    
    // 确保最小伤害
    const 最小伤害 = js_number_数值版(基本常量.最小攻击, '0', 1);
    if (js_war_数值版(伤害, 最小伤害) < 0) {
        伤害 = 最小伤害;
    }
    
    return 伤害;
}

// 如果需要返回string，在调用处转换
function 计算技能基础伤害(
    基础攻击: string,
    等级: number,
    基础倍率: number,
    等级倍率: number,
    额外倍攻: string,
    额外伤害: string
): string {
    return 计算技能基础伤害_数值版(
        基础攻击, 等级, 基础倍率, 等级倍率, 额外倍攻, 额外伤害
    ).toString();
}
```

### 示例2：玩家伤害计算（复杂场景）

**原版关键代码**：
```typescript
// 防御计算
let 敌人防御 = js_numberRandom2(敌人防御最小, 敌人防御最大);
敌人防御 = js_number(敌人防御, R.物理穿透, 2);

// 基础伤害
let 基础伤害 = js_number(最大攻击, 敌人防御, 2);

// 技能攻击计算
技能攻击 = js_number(技能攻击, String(修正), 3);
技能攻击 = js_number(技能攻击, '100', 3);
技能攻击 = js_number(技能攻击, 狂怒伤害, 1);
技能攻击 = js_number(技能攻击, js_number(技能攻击, String(伤害倍数), 3), 1);

// 暴击计算
const critMultiplier = js_number(js_number(js_number('0.5', String(暴击伤害), 1), R.暴击伤害, 1), '1', 1);
技能攻击 = js_number(技能攻击, critMultiplier, 3);
```

**数值版优化**：
```typescript
// 防御计算（转换为Decimal）
let 敌人防御 = js_numberRandom2(敌人防御最小, 敌人防御最大);
let 敌人防御Decimal = js_number_数值版(敌人防御, R.物理穿透, 2);

// 基础伤害（链式调用）
const 最大攻击Decimal = js_number_数值版(最大攻击, '0', 1);
let 基础伤害 = 最大攻击Decimal.minus(敌人防御Decimal);

// 技能攻击计算（链式调用，避免中间转换）
let 技能攻击 = 基础攻击Decimal;
if (修正 !== null) {
    技能攻击 = 技能攻击.mul(js_number_数值版(修正, '1', 1));
}
if (R.地图减伤) {
    技能攻击 = 技能攻击.mul(js_number_数值版('100', '1', 1));
}
if (狂怒伤害) {
    技能攻击 = 技能攻击.plus(js_number_数值版(狂怒伤害, '0', 1));
}
if (伤害倍数 !== 1) {
    const 倍数Decimal = js_number_数值版(伤害倍数, '1', 1);
    技能攻击 = 技能攻击.plus(技能攻击.mul(倍数Decimal));
}

// 暴击计算（链式调用）
if (random(100) < R.暴击几率) {
    const critMultiplier = js_number_数值版('0.5', '1', 1)
        .plus(js_number_数值版(暴击伤害, '0', 1))
        .plus(js_number_数值版(R.暴击伤害, '0', 1))
        .plus(js_number_数值版('1', '0', 1));
    技能攻击 = 技能攻击.mul(critMultiplier);
}
```

## 四、性能优化技巧

### 1. 缓存常用Decimal对象
```typescript
// 在模块顶部创建常用Decimal对象
const DECIMAL_ONE = js_number_数值版('1', '0', 1);
const DECIMAL_HUNDRED = js_number_数值版('100', '0', 1);
const DECIMAL_ZERO = js_number_数值版('0', '0', 1);

// 使用时直接复用
技能攻击 = 技能攻击.mul(DECIMAL_HUNDRED);
```

### 2. 减少类型转换
```typescript
// ❌ 不好：每次都转换
技能攻击 = js_number_数值版(技能攻击.toString(), String(修正), 3);

// ✅ 好：保持Decimal类型
技能攻击 = 技能攻击.mul(js_number_数值版(修正, '1', 1));
```

### 3. 批量计算优化
```typescript
// ❌ 不好：多次单独调用
let 结果 = js_number_数值版(a, b, 1);
结果 = js_number_数值版(结果, c, 1);
结果 = js_number_数值版(结果, d, 1);

// ✅ 好：链式调用（方式1：预先转换，性能最优）
let 结果 = js_number_数值版(a, b, 1)
    .plus(js_number_数值版(c, '0', 1))
    .plus(js_number_数值版(d, '0', 1));

// ✅ 更好：链式调用（方式2：直接传值，代码更简洁）
// Decimal.plus() 会自动转换 string | number 参数
let 结果 = js_number_数值版(a, b, 1)
    .plus(c)  // 自动转换为 Decimal
    .plus(d); // 自动转换为 Decimal

// 说明：
// - 方式2 代码更简洁，可读性更好
// - 方式1 性能略好（避免重复转换），但差异很小
// - 推荐使用方式2，除非是超高频调用场景
```
// 如果这个函数被调用非常频繁（每秒数千次）
// 可以考虑预先转换，利用 js_number_数值版 的缓存优化
const 额外伤害Decimal = js_number_数值版(安全额外伤害, '0', 1);
const 额外倍攻Decimal = js_number_数值版(安全额外倍攻, '1', 1);

const 伤害 = js_number_数值版(基础攻击, 总倍率, 3)
    .plus(额外伤害Decimal)
    .mul(额外倍攻Decimal);

## 五、迁移检查清单

### 步骤1：准备工作
- [ ] 备份原文件
- [ ] 创建新文件 `攻击计算_数值版.ts`
- [ ] 导入数值版函数

### 步骤2：修改函数签名
- [ ] 修改返回类型：`string` → `Decimal`
- [ ] 修改参数类型：支持 `number | string | Decimal`
- [ ] 在函数最后调用 `.toString()` 返回字符串（如果需要）

### 步骤3：替换计算函数
- [ ] 替换所有 `js_number()` → `js_number_数值版()`
- [ ] 替换所有 `js_war()` → `js_war_数值版()`
- [ ] 优化链式调用

### 步骤4：测试验证
- [ ] 单元测试：对比计算结果是否一致
- [ ] 性能测试：验证性能提升
- [ ] 集成测试：确保游戏逻辑正常

### 步骤5：部署
- [ ] 灰度发布：先在小范围测试
- [ ] 监控性能：观察CPU占用和响应时间
- [ ] 逐步推广：验证无误后全面替换

## 六、注意事项

### 1. 类型兼容性
- 数值版返回 `Decimal` 对象，需要时调用 `.toString()`
- 如果函数需要返回 `string`，在最后统一转换

### 2. 链式调用优化
- 中间结果保持 `Decimal` 类型
- 避免不必要的 `.toString()` 调用
- 只在最终输出时转换

### 3. 性能监控
- 使用性能测试工具验证提升
- 监控CPU占用和内存使用
- 对比字符串版和数值版的性能差异

## 七、预期效果

### 性能提升
- **链式调用场景**：40-50% 性能提升
- **整体攻击计算**：30-40% 性能提升
- **CPU占用**：减少 20-30%

### 代码质量
- 链式调用更优雅
- 类型更安全
- 减少字符串操作

### 维护性
- 代码更清晰
- 更容易优化
- 更好的类型检查

