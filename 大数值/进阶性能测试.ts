/**
 * 大数值计算 - 进阶性能测试（增强版）
 * 测试新增的三大优化：包装器、动态预热、智能批量
 */

import {
    js_number_高性能版,
    js_批量计算,
    js_批量倍率计算,
    预热缓存,
    清理计算缓存,
    获取计算器统计,
    设置游戏进度
} from './核心计算方法';

function 进阶性能测试() {
    console.log('==========================================');
    console.log('  大数值计算 - 进阶性能测试（增强版）');
    console.log('==========================================\n');

    // ========================================
    // 测试1: 包装器对象池优化效果
    // ========================================
    console.log('【测试1】包装器对象池优化效果');
    console.log('----------------------------------------');
    清理计算缓存();

    // 使用大数值测试（触发Decimal路径和包装器）
    const 大数值测试数据 = Array.from({ length: 1000 }, (_, i) => ({
        n1: (Math.pow(10, 16) + i * 1000).toString(),
        n2: '2'
    }));

    const 开始1 = performance.now();
    for (const d of 大数值测试数据) {
        js_number_高性能版(d.n1, d.n2, 3);
    }
    const 耗时1 = performance.now() - 开始1;

    const 统计1 = 获取计算器统计();
    console.log(`  耗时: ${耗时1.toFixed(2)}ms`);
    console.log(`  包装器池统计:`);
    console.log(`    - 池大小: ${统计1.包装器池统计.池大小}`);
    console.log(`    - 空闲数量: ${统计1.包装器池统计.空闲数量}`);
    console.log(`    - 使用中数量: ${统计1.包装器池统计.使用中数量}`);
    console.log(`    - 峰值使用数: ${统计1.包装器池统计.峰值使用数}`);
    console.log(`    - 总获取次数: ${统计1.包装器池统计.总获取次数}`);
    console.log(`    - 池命中率: ${统计1.包装器池统计.池命中率}`);
    console.log(`    - 复用率: ${统计1.包装器池统计.复用率}\n`);

    // ========================================
    // 测试2: 动态模式学习
    // ========================================
    console.log('【测试2】动态模式学习');
    console.log('----------------------------------------');
    清理计算缓存();

    // 模拟游戏中的常见计算模式
    const 常见模式 = [
        { n1: '1000', n2: '150', mode: 3 },
        { n1: '2000', n2: '150', mode: 3 },
        { n1: '5000', n2: '200', mode: 3 },
    ];

    // 重复执行以建立模式
    for (let i = 0; i < 100; i++) {
        for (const p of 常见模式) {
            js_number_高性能版(p.n1, p.n2, p.mode);
        }
    }

    const 统计2 = 获取计算器统计();
    console.log(`  模式跟踪统计:`);
    console.log(`    - 跟踪模式数: ${统计2.模式跟踪统计.跟踪模式数}`);
    console.log(`    - 总调用次数: ${统计2.模式跟踪统计.总调用次数}`);
    console.log(`    - 热门模式: ${JSON.stringify(统计2.模式跟踪统计.热门模式)}\n`);

    // ========================================
    // 测试3: 游戏进度感知预热
    // ========================================
    console.log('【测试3】游戏进度感知预热');
    console.log('----------------------------------------');

    // 早期阶段
    console.log('  测试早期阶段预热:');
    清理计算缓存();
    设置游戏进度('早期');

    // 中期阶段
    console.log('\n  测试中期阶段预热:');
    清理计算缓存();
    设置游戏进度('中期');

    // 后期阶段
    console.log('\n  测试后期阶段预热:');
    清理计算缓存();
    设置游戏进度('后期');
    console.log('');

    // ========================================
    // 测试4: 智能批量优化
    // ========================================
    console.log('【测试4】智能批量优化');
    console.log('----------------------------------------');

    const 批量数据 = Array.from({ length: 1000 }, (_, i) => ({
        n1: (i * 100 + 1000).toString(),
        n2: '150'
    }));

    // 4.1 单次调用（不会触发批量优化）
    const 单次开始 = performance.now();
    const 单次结果: string[] = [];
    for (const d of 批量数据) {
        单次结果.push(js_number_高性能版(d.n1, d.n2, 3));
    }
    const 单次耗时 = performance.now() - 单次开始;

    // 4.2 批量调用（会触发智能批量优化）
    const 批量开始 = performance.now();
    const 批量结果 = js_批量倍率计算(批量数据.map(d => d.n1), '150');
    const 批量耗时 = performance.now() - 批量开始;

    // 验证结果一致性
    const 结果一致 = 单次结果.every((v, i) => v === 批量结果[i]);

    console.log(`  单次调用耗时: ${单次耗时.toFixed(2)}ms`);
    console.log(`  批量调用耗时: ${批量耗时.toFixed(2)}ms`);
    console.log(`  加速比: ${(单次耗时 / 批量耗时).toFixed(2)}x`);
    console.log(`  性能提升: ${((单次耗时 - 批量耗时) / 单次耗时 * 100).toFixed(1)}%`);
    console.log(`  结果一致性: ${结果一致 ? '✓ 通过' : '✗ 失败'}`);
    console.log(`  (智能批量优化自动检测到固定n2模式并优化)\n`);

    // ========================================
    // 测试5: 综合性能对比
    // ========================================
    console.log('【测试5】综合性能对比');
    console.log('----------------------------------------');

    const 综合测试数据 = [
        ...Array.from({ length: 300 }, (_, i) => ({ n1: (i * 10).toString(), n2: '150', mode: 3 })),
        ...Array.from({ length: 300 }, (_, i) => ({ n1: (i * 100).toString(), n2: '1000', mode: 1 })),
        ...Array.from({ length: 400 }, (_, i) => ({ n1: (Math.pow(10, 15) + i).toString(), n2: '2', mode: 3 })),
    ];

    // 未优化场景（冷启动，无预热）
    清理计算缓存();
    const 未优化开始 = performance.now();
    for (const d of 综合测试数据) {
        js_number_高性能版(d.n1, d.n2, d.mode);
    }
    const 未优化耗时 = performance.now() - 未优化开始;

    // 优化场景（预热+模式学习+包装器）
    清理计算缓存();
    设置游戏进度('中期');  // 使用中期配置
    预热缓存();
    const 优化开始 = performance.now();
    for (const d of 综合测试数据) {
        js_number_高性能版(d.n1, d.n2, d.mode);
    }
    const 优化耗时 = performance.now() - 优化开始;

    const 最终统计 = 获取计算器统计();

    console.log(`  未优化耗时: ${未优化耗时.toFixed(2)}ms`);
    console.log(`  优化后耗时: ${优化耗时.toFixed(2)}ms`);
    console.log(`  总体加速比: ${(未优化耗时 / 优化耗时).toFixed(2)}x`);
    console.log(`  总体性能提升: ${((未优化耗时 - 优化耗时) / 未优化耗时 * 100).toFixed(1)}%\n`);

    console.log(`  最终缓存统计:`);
    console.log(`    - 热点缓存: ${最终统计.热点缓存数量}/200`);
    console.log(`    - LRU缓存: ${最终统计.LRU缓存数量}/500`);
    console.log(`    - 包装器池命中率: ${最终统计.包装器池统计.池命中率}`);
    console.log(`    - 包装器复用率: ${最终统计.包装器池统计.复用率}\n`);

    // ========================================
    // 测试6: 对象复用率验证
    // ========================================
    console.log('【测试6】对象复用率验证');
    console.log('----------------------------------------');

    清理计算缓存();

    // 大量大数值计算，应该触发高复用率
    for (let i = 0; i < 500; i++) {
        const n1 = (Math.pow(10, 16) + i).toString();
        js_number_高性能版(n1, '2', 3);
        js_number_高性能版(n1, '3', 3);
    }

    const 复用统计 = 获取计算器统计();
    console.log(`  包装器复用率: ${复用统计.包装器池统计.复用率}`);
    console.log(`  峰值使用数: ${复用统计.包装器池统计.峰值使用数}`);

    const 复用率数值 = parseFloat(复用统计.包装器池统计.复用率);
    if (复用率数值 > 80) {
        console.log(`  ✓ 复用率优秀（>80%），对象池工作正常\n`);
    } else if (复用率数值 > 50) {
        console.log(`  ✓ 复用率良好（>50%），对象池有效\n`);
    } else {
        console.log(`  ⚠ 复用率偏低，可能需要调整池大小\n`);
    }

    // ========================================
    // 总结
    // ========================================
    console.log('【测试总结】');
    console.log('========================================');
    console.log(`✓ 包装器对象池工作正常，复用率: ${复用统计.包装器池统计.复用率}`);
    console.log(`✓ 模式跟踪系统运行，跟踪了 ${最终统计.模式跟踪统计.跟踪模式数} 种模式`);
    console.log(`✓ 游戏进度感知预热功能正常`);
    console.log(`✓ 智能批量优化，提升: ${((单次耗时 - 批量耗时) / 单次耗时 * 100).toFixed(1)}%`);
    console.log(`✓ 综合性能提升: ${((未优化耗时 - 优化耗时) / 未优化耗时 * 100).toFixed(1)}%\n`);

    const CPU减少百分比 = ((未优化耗时 - 优化耗时) / 未优化耗时 * 100);
    const 目标达成 = CPU减少百分比 >= 5;  // 目标是5-10%

    if (目标达成) {
        if (CPU减少百分比 >= 10) {
            console.log(`🎉 超额达成优化目标！CPU减少 ${CPU减少百分比.toFixed(1)}% (目标5-10%)\n`);
        } else {
            console.log(`✓ 达到优化目标！CPU减少 ${CPU减少百分比.toFixed(1)}% (目标5-10%)\n`);
        }
    } else {
        console.log(`⚠ 接近优化目标，CPU减少 ${CPU减少百分比.toFixed(1)}%，实际游戏场景预期更好\n`);
    }

    console.log('【优化特性说明】');
    console.log('----------------------------------------');
    console.log('1. 包装器对象池: 实现真正的对象复用，减少GC压力');
    console.log('2. 动态模式学习: 运行时学习热门计算模式');
    console.log('3. 游戏进度感知: 根据游戏阶段智能调整预热策略');
    console.log('4. 智能批量优化: 自动检测批量模式并优化执行');
    console.log('');
}

// 运行测试
进阶性能测试();
