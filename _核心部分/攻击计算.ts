

import { 大数值整数简写, 随机小数, } from "../_核心部分/字符计算";
import { _P_N_可复活次数, 技能ID, 特效, 永久特效, TAG, 怪物鞭尸不复活, 原始名字 } from "../_核心部分/基础常量";

import { 实时回血, 攻击飘血, 血量显示 } from "./字符计算";
import { CheckBuffGroupID, 技能ID转换技能名称 } from "../_核心部分/_功能";
import * as 地图 from './_地图/地图';
import { 智能计算, 转大数值, js_百分比, js_范围随机, js_war } from "../_大数值/核心计算方法";
import { 装备属性统计 } from "./_装备/属性统计";
import { 增加击杀计数, 特殊BOSS死亡, 大陆BOSS死亡 } from "./_生物/生物刷新";
import { 执行掉落 } from "./_装备/爆率系统";

// ==================== 受伤被动技能计算（从MagicNpc.ts整合） ====================

/**
 * 计算受伤时的被动技能效果（供外部调用）
 * @param Player 玩家对象
 * @param 伤害 受到的伤害值(字符串)
 * @returns 计算后的伤害值(字符串)
 */
export function 计算受伤被动(Player: TPlayObject, 伤害: string): string {
    const V = Player.V;
    const R = Player.R;
    let 最终伤害 = 伤害;

    // 血神 - 血气吸纳：被攻击1%几率恢复5%血量,每20级几率提高1%,(最高到40)
    if (V.职业 === '血神') {
        const 血气吸纳 = Player.FindSkill('血气吸纳');
        if (血气吸纳) {
            const 几率 = Math.min(5 + Math.floor(血气吸纳.Level / 50), 20);
            if (random(100) < 几率) {
                const 恢复量 = 智能计算(Player.GetSVar(92), '0.03', 3);
                实时回血(Player, 恢复量);
                Player.SendMessage(`【血气吸纳】触发! 恢复3%血量`, 2);
            }
        }
    }

    // 不动 - 铁布衫：提供5%格挡，每50级提高1%（40上限）
    if (V.职业 === '不动') {
        const 铁布衫 = Player.FindSkill('铁布衫');
        if (铁布衫) {
            const 格挡几率 = Math.min(5 + Math.floor(铁布衫.Level / 50), 40);
            if (random(150) < 格挡几率) {
                最终伤害 = '0';
                Player.SendMessage(`【铁布衫】格挡成功!`, 2);
            }
        }

        // 人王盾护盾吸收（使用大数值计算）
        if (R.人王盾护盾值 && R.人王盾护盾值 !== '0') {
            const 护盾剩余 = 智能计算(R.人王盾护盾值, 伤害, 2);
            // 判断护盾是否足够
            if (护盾剩余[0] !== '-') {
                R.人王盾护盾值 = 护盾剩余;
                最终伤害 = '0';
                if (V.护盾提示) {
                    Player.SendMessage(`【人王盾】吸收伤害,剩余护盾${大数值整数简写(R.人王盾护盾值)}`, 2);
                }
            } else {
                // 护盾不足，计算溢出伤害
                最终伤害 = 智能计算(伤害, R.人王盾护盾值, 2);
                R.人王盾护盾值 = '0';
                Player.SetCustomEffect(永久特效.关闭, -1);
                Player.SendMessage(`【人王盾】护盾破碎!`, 2);
            }
        }
    }

    return 最终伤害;
}


// #region 地图伤害修正
/**
 * 地图伤害修正系数配置
 * 使用扁平化的Map结构提高查找效率
 */
const 地图伤害修正系数 = new Map<number, number>([

    [21, 0.003],
    [22, 0.001],
    [23, 0.00001],
    [24, 0.00001],
    [25, 0.00001],
    [26, 0.00001],
    [27, 0.00001],
    [28, 0.00001],
    [29, 0.00001],
    [30, 0.000001],
    [31, 0.0000001],
    [32, 0.00000003],
    [33, 0.000000009],
    [34, 0.0000000027],
    [35, 0.00000000081],
    [36, 0.000000000243],
    [37, 0.0000000000729],
    [38, 0.00000000002187],
    [39, 0.000000000006561],
    [40, 0.0000000000019683],
    [41, 0.00000000000000001],
    [42, 0.000000000000000001],
    // 其他等级地图配置.000..
]);

/**
 * 获取地图伤害修正系数 - 优化后的O(1)查找
 */
function 获取地图伤害修正(地图等级: number): number | null {
    return 地图伤害修正系数.get(地图等级) ?? null;
}
// #endregion

// #region 数值安全处理工具（优化版）
/**
 * 安全数值转换函数，防止NaN和无效值（优化：减少类型转换）
 */
const safeNumber = (value: any): number => {
    if (typeof value === 'number') return isNaN(value) ? 0 : value;
    const num = Number(value);
    return isNaN(num) ? 0 : num;
};

/**
 * 安全字符串数值转换（优化：提前返回，减少字符串操作）
 */
const 安全数值 = (value: any, defaultValue = '0'): string => {
    if (!value && value !== 0) return defaultValue;
    if (typeof value === 'string') {
        // 快速检查无效值
        const firstChar = value[0];
        if (firstChar === 'N' || firstChar === 'I' || firstChar === '-' && value[1] === 'I') {
            return defaultValue;
        }
        return value;
    }
    return String(value);
};

/**
 * 安全魔次数值转换（优化：减少重复检查）
 */
const 安全字符 = (value: any, defaultValue = '1'): string => {
    if (!value) return defaultValue;
    if (typeof value === 'string') {
        const firstChar = value[0];
        if (firstChar === 'N' || firstChar === 'I' || firstChar === '-') return defaultValue;
        return value;
    }
    const num = Number(value);
    return (isNaN(num) || num <= 0) ? defaultValue : String(value);
};

/**
 * 检查并修复无效的伤害值（优化：快速路径）
 */
const sanitizeDamage = (damage: string, fallback = '1'): string => {
    if (!damage) return fallback;
    const firstChar = damage[0];
    // 快速检查：N(NaN), I(Infinity), 0, -(负数)
    if (firstChar === 'N' || firstChar === 'I' || firstChar === '0' && damage.length === 1) {
        return fallback;
    }
    return damage;
};

// #endregion

// #region 常量定义
const 基本常量 = {
    最小攻击: '1',
    基础数值: '0',
    基础属性: '500',
} as const;

// #region 技能伤害配置
/**
 * 技能伤害计算配置类
 */
class 技能属性 {
    constructor(
        public 基础加成: number,
        public 等级加成: number,
        public hasSpecialEffect: boolean = false,
        public specialEffectHandler?: (player: TPlayObject, enemy: TActor) => void
    ) { }
}

/**
 * 技能配置映射表 - 根据_P_Base.ts定义和职业选择.ts描述
 */
const SKILL_CONFIGS = new Map<number, 技能属性>([
    // ========== 基础技能 ==========
    [技能ID.基础技能.攻杀剑术, new 技能属性(2, 0.2)],         // 200%基础,每级+20%
    [技能ID.基础技能.半月弯刀, new 技能属性(1.5, 0.15)],      // 150%基础,每级+15%
    [技能ID.基础技能.雷电术, new 技能属性(2, 0.2)],           // 200%基础,每级+20%
    [技能ID.基础技能.暴风雪, new 技能属性(1, 0.1)],           // 100%基础,每级+10%
    [技能ID.基础技能.灵魂火符, new 技能属性(2, 0.2)],         // 200%基础,每级+20%
    [技能ID.基础技能.飓风破, new 技能属性(1.2, 0.12)],        // 120%基础,每级+12%
    [技能ID.基础技能.暴击术, new 技能属性(1.5, 0.15)],        // 150%基础,每级+15%
    [技能ID.基础技能.霜月, new 技能属性(1.5, 0.15)],          // 150%基础,每级+15%
    [技能ID.基础技能.精准箭术, new 技能属性(2, 0.2)],         // 200%基础,每级+20%
    [技能ID.基础技能.万箭齐发, new 技能属性(1.2, 0.12)],      // 120%基础,每级+12%
    [技能ID.基础技能.罗汉棍法, new 技能属性(1.5, 0.15)],      // 150%基础,每级+15%
    [技能ID.基础技能.天雷阵, new 技能属性(1.2, 0.12)],        // 120%基础,每级+12%

    // ========== 天枢职业 (10000-10004) ==========
    // 怒斩: 主动,对目标周围3码内所有敌人造成伤害200%,每级提高20%
    [技能ID.天枢.怒斩, new 技能属性(2, 0.2)],
    // 人之怒: 被动,攻击时20%几率使你造成得伤害额外提高400%,每级提高40%
    [技能ID.天枢.人之怒, new 技能属性(4, 0.4)],
    // 地之怒: 被动,攻击时10%几率使你造成得伤害额外提高600%,每级提高60%
    [技能ID.天枢.地之怒, new 技能属性(6, 0.6)],
    // 天之怒: 被动,攻击时5%几率使你造成得伤害额外提高800%,每级提高80%
    [技能ID.天枢.天之怒, new 技能属性(8, 0.8)],
    // 神之怒: 被动,攻击时1%几率使你造成得伤害额外提高1000%,每级提高100%
    [技能ID.天枢.神之怒, new 技能属性(10, 1.0)],

    // ========== 血神职业 (10005-10009) ==========
    // 血气献祭: 主动,消耗1%的生命,对目标造成500%的伤害,每级提高50%
    [技能ID.血神.血气献祭, new 技能属性(5, 0.5)],
    // 血气燃烧: 开启后,每秒对周围5码范围内敌人造成150%的伤害,每级提高15%
    [技能ID.血神.血气燃烧, new 技能属性(1.5, 0.15)],
    // 血气吸纳: 被动,被攻击1%几率恢复5%血量,每20级几率提高1%
    [技能ID.血神.血气吸纳, new 技能属性(1, 0.01)],
    // 血气迸发: 被动,攻击时可吸取造成伤害的1‰转化为生命,每级提高1‰
    [技能ID.血神.血气迸发, new 技能属性(1, 0.001)],
    // 血魔临身: 开启后,使你的攻击额外提高150%,每级提高5%
    [技能ID.血神.血魔临身, new 技能属性(1.5, 0.05)],

    // ========== 暗影职业 (10010-10014) ==========
    // 暗影猎取: 被动,攻击1%的几率获取暗影值
    // [技能ID.暗影.暗影猎取, new 技能属性(1, 0.01)],
    // 暗影袭杀: 主动,对目标造成500%伤害,每级提高50%
    [技能ID.暗影.暗影袭杀, new 技能属性(5, 0.5)],
    // 暗影剔骨: 开启后,对周围6码范围内敌人造成300%伤害,每级提高30%
    [技能ID.暗影.暗影剔骨, new 技能属性(3, 0.3)],
    // 暗影风暴: 主动,对目标范围5码内敌人造成400%伤害,每级提高40%
    [技能ID.暗影.暗影风暴, new 技能属性(4, 0.4)],
    // 暗影附体: 主动,使暗影袭杀的攻击提高至1000%
    [技能ID.暗影.暗影附体, new 技能属性(10, 0)],

    // ========== 烈焰职业 (10015-10019) ==========
    // 火焰追踪: 主动,对目标造成200%伤害,每级提高20%
    [技能ID.烈焰.火焰追踪, new 技能属性(2, 0.2)],
    // 火镰狂舞: 被动,每10级可为火焰追踪的目标增加一个
    [技能ID.烈焰.火镰狂舞, new 技能属性(1, 0)],
    // 烈焰护甲: 开启后,每2秒对周围4格内的目标造成300%伤害,每级提高30%
    [技能ID.烈焰.烈焰护甲, new 技能属性(3, 0.3)],
    // 爆裂火冢: 被动,击中目标20%几率造成8格范围300%伤害,每级提高30%
    [技能ID.烈焰.爆裂火冢, new 技能属性(3, 0.3)],
    // 烈焰突袭: 被动,每攻击5次,使你下次伤害提升至200%,每重+20%
    [技能ID.烈焰.烈焰突袭, new 技能属性(2, 0.2)],

    // ========== 正义职业 (10020-10024) ==========
    // 正义(圣光): 开启后,每秒对周围5码内所有目标造成200%伤害,每级提高20%
    [技能ID.正义.圣光, new 技能属性(2, 0.2)],
    // 行刑: 被动,对普通怪物的伤害增加200%，每级提高20%
    [技能ID.正义.行刑, new 技能属性(2, 0.2)],
    // 洗礼: 被动,对精英以上怪物的伤害增加100%，每级提高10%
    [技能ID.正义.洗礼, new 技能属性(1, 0.1)],
    // 审判: 被动,对满血目标造成10%血量切割，每20级+1%切割,封顶40%
    [技能ID.正义.审判, new 技能属性(1, 0)],
    // 神罚: 被动,攻击10%几率使目标遭受神罚，损失当前生命的1%，每40级+1%
    [技能ID.正义.神罚, new 技能属性(1, 0)],

    // ========== 不动职业 (10025-10029) ==========
    // 如山: 开启后,每秒对周围5码内造成400%伤害,每级提高40%
    [技能ID.不动.如山, new 技能属性(4, 0.4)],
    // 泰山: 被动,主属性提高30%,每级增加3%
    [技能ID.不动.泰山, new 技能属性(1.3, 0.03)],
    // 人王盾: 主动,释放技能提供一个防御上限值1000%的护盾，每级提高100%
    [技能ID.不动.人王盾, new 技能属性(10, 1)],
    // 铁布衫: 被动,提供20%格挡，每10级提高1%（50上限）
    [技能ID.不动.铁布衫, new 技能属性(1, 0)],
    // 金刚掌: 主动,对目标周围8格范围造成500%伤害,并麻痹目标3秒,每级提高50%
    [技能ID.不动.金刚掌, new 技能属性(5, 0.5, true, (_player, enemy) => {
        enemy.SetState(5, 3, 0); // 麻痹3秒
    })],
]);

// 职业被动技能触发几率常量（根据职业选择.ts描述）
const 被动触发几率 = {
    人之怒: 20,    // 20%几率
    地之怒: 10,    // 10%几率
    天之怒: 5,     // 5%几率
    神之怒: 1,     // 1%几率
    暗影猎取: 10,   // 10%几率获取暗影值
    神罚: 10,      // 10%几率
    爆裂火冢: 20   // 20%几率
} as const;


/**
 * 技能属性获取器 - 根据_P_Base.ts定义
 * 返回: { 等级, 魔次, 伤害 }
 */
const getSkillAttributes = (自己: TPlayObject, 技能序号: number) => {
    const V = 自己.V;
    const R = 自己.R;

    switch (技能序号) {
        // ========== 基础技能 ==========
        case 技能ID.基础技能.攻杀剑术: return { 等级: V.攻杀剑术等级 || 1, 魔次: R.攻杀剑术魔次 || '1', 伤害: '0' };
        case 技能ID.基础技能.半月弯刀: return { 等级: V.半月弯刀等级 || 1, 魔次: R.半月弯刀魔次 || '1', 伤害: '0' };
        case 技能ID.基础技能.雷电术: return { 等级: V.雷电术等级 || 1, 魔次: R.雷电术魔次 || '1', 伤害: '0' };
        case 技能ID.基础技能.暴风雪: return { 等级: V.暴风雪等级 || 1, 魔次: R.暴风雪魔次 || '1', 伤害: '0' };
        case 技能ID.基础技能.灵魂火符: return { 等级: V.灵魂火符等级 || 1, 魔次: R.灵魂火符魔次 || '1', 伤害: '0' };
        case 技能ID.基础技能.飓风破: return { 等级: V.飓风破等级 || 1, 魔次: R.飓风破魔次 || '1', 伤害: '0' };
        case 技能ID.基础技能.暴击术: return { 等级: V.暴击术等级 || 1, 魔次: R.暴击术魔次 || '1', 伤害: '0' };
        case 技能ID.基础技能.霜月: return { 等级: V.霜月等级 || 1, 魔次: R.霜月魔次 || '1', 伤害: '0' };
        case 技能ID.基础技能.精准箭术: return { 等级: V.精准箭术等级 || 1, 魔次: R.精准箭术魔次 || '1', 伤害: '0' };
        case 技能ID.基础技能.万箭齐发: return { 等级: V.万箭齐发等级 || 1, 魔次: R.万箭齐发魔次 || '1', 伤害: '0' };
        case 技能ID.基础技能.罗汉棍法: return { 等级: V.罗汉棍法等级 || 1, 魔次: R.罗汉棍法魔次 || '1', 伤害: '0' };
        case 技能ID.基础技能.天雷阵: return { 等级: V.天雷阵等级 || 1, 魔次: R.天雷阵魔次 || '1', 伤害: '0' };

        // ========== 天枢职业 ==========
        case 技能ID.天枢.怒斩: return { 等级: V.怒斩等级 || 1, 魔次: R.怒斩魔次 || '1', 伤害: '0' };
        case 技能ID.天枢.人之怒: return { 等级: V.人之怒等级 || 1, 魔次: '1', 伤害: '0' };
        case 技能ID.天枢.地之怒: return { 等级: V.地之怒等级 || 1, 魔次: '1', 伤害: '0' };
        case 技能ID.天枢.天之怒: return { 等级: V.天之怒等级 || 1, 魔次: '1', 伤害: '0' };
        case 技能ID.天枢.神之怒: return { 等级: V.神之怒等级 || 1, 魔次: '1', 伤害: '0' };

        // ========== 血神职业 ==========
        case 技能ID.血神.血气献祭: return { 等级: V.血气献祭等级 || 1, 魔次: R.血气献祭魔次 || '1', 伤害: '0' };
        case 技能ID.血神.血气燃烧: return { 等级: V.血气燃烧等级 || 1, 魔次: R.血气燃烧魔次 || '1', 伤害: '0' };
        case 技能ID.血神.血气吸纳: return { 等级: V.血气吸纳等级 || 1, 魔次: R.血气吸纳魔次 || '1', 伤害: '0' };
        case 技能ID.血神.血气迸发: return { 等级: V.血气迸发等级 || 1, 魔次: R.血气迸发魔次 || '1', 伤害: '0' };
        case 技能ID.血神.血魔临身: return { 等级: V.血魔临身等级 || 1, 魔次: '1', 伤害: '0' };

        // ========== 暗影职业 ==========
        case 技能ID.暗影.暗影猎取: return { 等级: V.暗影猎取等级 || 1, 魔次: R.暗影猎取魔次 || '1', 伤害: '0' };
        case 技能ID.暗影.暗影袭杀: return { 等级: V.暗影袭杀等级 || 1, 魔次: R.暗影袭杀魔次 || '1', 伤害: '0' };
        case 技能ID.暗影.暗影剔骨: return { 等级: V.暗影剔骨等级 || 1, 魔次: R.暗影剔骨魔次 || '1', 伤害: '0' };
        case 技能ID.暗影.暗影风暴: return { 等级: V.暗影风暴等级 || 1, 魔次: R.暗影风暴魔次 || '1', 伤害: '0' };
        case 技能ID.暗影.暗影附体: return { 等级: V.暗影附体等级 || 1, 魔次: '1', 伤害: '0' };

        // ========== 烈焰职业 ==========
        case 技能ID.烈焰.火焰追踪: return { 等级: V.火焰追踪等级 || 1, 魔次: R.火焰追踪魔次 || '1', 伤害: '0' };
        case 技能ID.烈焰.火镰狂舞: return { 等级: V.火镰狂舞等级 || 1, 魔次: R.火镰狂舞魔次 || '1', 伤害: '0' };
        case 技能ID.烈焰.烈焰护甲: return { 等级: V.烈焰护甲等级 || 1, 魔次: R.烈焰护甲魔次 || '1', 伤害: '0' };
        case 技能ID.烈焰.爆裂火冢: return { 等级: V.爆裂火冢等级 || 1, 魔次: R.爆裂火冢魔次 || '1', 伤害: '0' };
        case 技能ID.烈焰.烈焰突袭: return { 等级: V.烈焰突袭等级 || 1, 魔次: R.烈焰突袭魔次 || '1', 伤害: '0' };

        // ========== 正义职业 ==========
        case 技能ID.正义.圣光: return { 等级: V.圣光等级 || 1, 魔次: R.圣光魔次 || '1', 伤害: '0' };
        case 技能ID.正义.行刑: return { 等级: V.行刑等级 || 1, 魔次: R.行刑魔次 || '1', 伤害: '0' };
        case 技能ID.正义.洗礼: return { 等级: V.洗礼等级 || 1, 魔次: R.洗礼魔次 || '1', 伤害: '0' };
        case 技能ID.正义.审判: return { 等级: V.审判等级 || 1, 魔次: R.审判魔次 || '1', 伤害: '0' };
        case 技能ID.正义.神罚: return { 等级: V.神罚等级 || 1, 魔次: R.神罚魔次 || '1', 伤害: '0' };

        // ========== 不动职业 ==========
        case 技能ID.不动.如山: return { 等级: V.如山等级 || 1, 魔次: R.如山魔次 || '1', 伤害: '0' };
        case 技能ID.不动.泰山: return { 等级: V.泰山等级 || 1, 魔次: R.泰山魔次 || '1', 伤害: '0' };
        case 技能ID.不动.人王盾: return { 等级: V.人王盾等级 || 1, 魔次: '1', 伤害: '0' };
        case 技能ID.不动.铁布衫: return { 等级: V.铁布衫等级 || 1, 魔次: '1', 伤害: '0' };
        case 技能ID.不动.金刚掌: return { 等级: V.金刚掌等级 || 1, 魔次: R.金刚掌魔次 || '1', 伤害: '0' };

        default: return undefined;
    }
};
// #endregion

/**
 * 检查攻击是否合法（优化版）
 */
function 检查攻击合法性(自己: TActor, 敌人: TActor): boolean {
    // 优化：快速路径 - 基础检查
    if (!自己 || !敌人 || 自己.Handle === 敌人.Handle) return false;
    if (自己.GetDeath() || 敌人.GetDeath()) return false;
    if (自己.GetInSafeZone() || 敌人.GetInSafeZone()) return false;

    // 优化：主人检查
    const 自己主人 = 自己.Master;
    const 敌人主人 = 敌人.Master;
    if (自己主人 && 敌人主人 && 自己主人.Name === 敌人主人.Name) return false;
    if (敌人主人?.Handle === 自己.Handle) return false;

    // 玩家特殊检查
    if (自己.IsPlayer()) {
        const aPlayer = 自己 as TPlayObject;
        const 攻击模式 = aPlayer.GetAttackMode();

        // 优化：和平模式检查
        if (攻击模式 === 1 && (敌人.IsPlayer() || 敌人主人 != null)) return false;

        // 优化：善恶模式检查
        if (攻击模式 === 6 && 敌人.IsPlayer() && 敌人.GetPkLevel() < 2) return false;

        // 优化：行会模式检查
        if (攻击模式 === 5 && aPlayer.Guild && 敌人.Guild && aPlayer.Guild.Name === 敌人.Guild.Name) return false;

        // 优化：组队模式检查
        if (攻击模式 === 4 && aPlayer.GroupOwner && 敌人.IsPlayer()) {
            const 敌人Handle = 敌人.Handle;
            for (let i = 0; i < aPlayer.GroupCount; i++) {
                const member = aPlayer.GetGroupMember(i);
                if (member?.Handle === 敌人Handle) return false;
            }
        }

        // 优化：宠物检查（缓存Handle）
        const 敌人Handle = 敌人.Handle;
        for (let i = 0; i <= aPlayer.SlaveCount; i++) {
            const slave = aPlayer.GetSlave(i);
            if (slave?.Handle === 敌人Handle) return false;
        }
    }

    return true;
}



/**
 * 计算玩家对敌人的伤害
 * 
 * 新伤害计算公式：
 * 最终伤害 = (人物主属性 - 生物防御) * 技能加成 * (攻击技能魔次 - 生物魔次抵抗) * 2^基因等级 * 伤害加成 * 暴击倍率
 * 
 * 计算步骤：
 * 1. 获取人物主属性（根据JOB：0-5对应R.自定属性[161-166]）
 * 2. 减去生物防御（应用无视防御）
 * 3. 乘以技能加成倍率（基础加成 + 等级 * 等级加成）
 * 4. 乘以有效魔次（攻击技能魔次 - 生物魔次抵抗，最小为1）
 * 5. 乘以基因倍率（2^基因等级）
 * 6. 应用伤害加成（基因攻击伤害、神器增伤等）
 * 7. 应用暴击（几率触发，基础2倍+额外暴击伤害）
 * 8. 应用地图伤害修正
 * 9. 应用职业被动技能效果
 * 
 * @param 自己 玩家对象
 * @param 敌人 目标敌人
 * @param 技能序号 使用的技能ID
 * @returns 最终伤害值（字符串）
 */
function 计算玩家伤害(自己: TPlayObject, 敌人: TActor, 技能序号: number): string {
    // 优化：缓存常用属性访问
    const V = 自己.V;
    const R = 自己.R;

    // 直接获取怪物属性（不需要随机，已经在生物属性中计算好）
    const 地图等级 = 地图.地图ID取固定星级(敌人.Map.MapID);
    let 敌人防御 = 敌人.GetSVar(94) || '0';  // SVar(94) = 防御
    let 敌人魔次抵抗 = 敌人.GetSVar(95) || '0';  // SVar(95) = 魔次抵抗

    // 确保自定属性对象已初始化
    if (!R.自定属性 || typeof R.自定属性 !== 'object') {
        R.自定属性 = {};
        // 初始化所有职业的默认攻击值
        for (let i = 161; i <= 166; i++) {
            R.自定属性[i] = 基本常量.基础属性;
        }
    }

    // 获取人物主属性（根据JOB：0-5对应161-166）
    const 主属性索引 = 自己.Job + 161;
    let 人物主属性 = 安全数值(R.自定属性[主属性索引], 基本常量.基础属性);

    // 应用无视防御（迅疾基因）- 优化：减少一次函数调用
    if (R.无视防御 && R.无视防御 > 0) {
        const 无视比例 = String(R.无视防御 * 0.01);
        const 无视量 = 智能计算(敌人防御, 无视比例, 3);
        敌人防御 = 智能计算(敌人防御, 无视量, 2);
        if (js_war(敌人防御, '0') < 0) {
            敌人防御 = '0';
        }
    }

    // 第一步：人物主属性 - 生物防御
    let 基础伤害 = 智能计算(人物主属性, 敌人防御, 2);
    if (js_war(基础伤害, '0') <= 0) {
        基础伤害 = '1';
    }

    // 确保最小伤害
    基础伤害 = sanitizeDamage(基础伤害, 基本常量.最小攻击);
    let 幸运 = 0
    if (V.幸运值 >= 100) {
        幸运 = 1;
    } else if (V.幸运值 < 100 && V.幸运值 >= 80) {
        幸运 = 随机小数(0.8, 1)
    } else if (V.幸运值 < 80 && V.幸运值 >= 50) {
        幸运 = 随机小数(0.5, 0.8)
    } else if (V.幸运值 < 50 && V.幸运值 >= 0) {
        幸运 = 随机小数(0.3, 0.5)
    }

    基础伤害 = 智能计算(基础伤害, String(幸运), 3)
    let 技能攻击 = 基础伤害;

    // ========== 六大职业被动技能触发（优化版） ==========
    const 职业 = V.职业;
    if (职业) {
        switch (职业) {
            case '天枢': {
                // 天枢被动：几率触发额外伤害（从高到低判断，只触发一个）
                const rand = random(100);
                if (rand < 被动触发几率.神之怒) {
                    const 等级 = V.神之怒等级 || 1;
                    技能攻击 = 智能计算(技能攻击, String(10 + 等级), 3);
                    自己.SendCountDownMessage(`【神之怒】触发！`, 0);
                } else if (rand < 被动触发几率.天之怒) {
                    const 等级 = V.天之怒等级 || 1;
                    技能攻击 = 智能计算(技能攻击, String(8 + 等级 * 0.8), 3);
                    自己.SendCountDownMessage(`【天之怒】触发！`, 0);
                } else if (rand < 被动触发几率.地之怒) {
                    const 等级 = V.地之怒等级 || 1;
                    技能攻击 = 智能计算(技能攻击, String(6 + 等级 * 0.6), 3);
                    自己.SendCountDownMessage(`【地之怒】触发！`, 0);
                } else if (rand < 被动触发几率.人之怒) {
                    const 等级 = V.人之怒等级 || 1;
                    技能攻击 = 智能计算(技能攻击, String(4 + 等级 * 0.4), 3);
                    自己.SendCountDownMessage(`【人之怒】触发！`, 0);
                }
                break;
            }
            case '血神': {
                // 血气迸发：吸血
                const 等级 = V.血气迸发等级 || 1;
                const 吸血千分比 = Math.min(1 + 等级, 2000);
                const 吸血量 = 智能计算(技能攻击, String(吸血千分比 / 1000), 3);
                if (js_war(自己.GetSVar(91), 自己.GetSVar(92)) < 0) {
                    实时回血(自己, 吸血量);
                }
                // 血魔临身：回血效果在RobotManageNpc中处理，不再提供攻击加成
                break;
            }
            case '暗影': {
                // 暗影猎取：1%几率获取暗影值
                if (random(100) < 被动触发几率.暗影猎取) {
                    const 等级 = V.暗影猎取等级 || 1;
                    const 上限 = Math.floor(等级 / 5) + 100;
                    R.暗影值 = Math.min((R.暗影值 || 0) + 1, 上限);
                    装备属性统计(自己)
                    let 暗影猎取 = 自己.AddIntervalBuff(1, TBuffIntervalType.biNone, 0, 0, 0, 0)
                    自己.SetBuffIcon(暗影猎取.Handle, 'magicon.wzl', 2312, 2312, ``, '', `{S=当前暗影值: ${自己.R.暗影值} 点}`, true, true)
                    自己.SendCountDownMessage(`获得暗影值！当前:${R.暗影值}/${上限}`, 0);
                }
                // // 暗影值加成
                // if (R.暗影值 > 0) {
                //     技能攻击 = 智能计算(技能攻击, String(1 + R.暗影值 * 0.01), 3);
                // }
                // 暗影附体状态
                if (R.暗影附体 && 技能序号 === 技能ID.暗影.暗影袭杀) {
                    技能攻击 = 智能计算(技能攻击, '10', 3);
                }


                break;
            }
            case '烈焰': {
                // 烈焰突袭：每5次攻击触发
                R.烈焰突袭计数 = (R.烈焰突袭计数 || 0) + 1;
                if (R.烈焰突袭计数 >= 5) {
                    R.烈焰突袭计数 = 0;
                    const 等级 = V.烈焰突袭等级 || 1;
                    技能攻击 = 智能计算(技能攻击, String(2 + 等级 * 0.2), 3);
                    自己.SendCountDownMessage(`【烈焰突袭】触发！`, 0);
                }
                // 爆裂火冢：20%几率造成3格范围300%伤害,每级提高30%
                // if (random(100) < 被动触发几率.爆裂火冢) {
                //     const 爆裂等级 = V.爆裂火冢等级 || 1;
                //     const 爆裂伤害倍率 = 3 + 爆裂等级 * 0.3; // 300% + 30%/级
                //     const 爆裂范围伤害 = 智能计算(技能攻击, String(爆裂伤害倍率), 3);
                //     // 对8格范围内敌人造成伤害
                //     const 范围目标列表 = 敌人.Map.GetActorListInRange(敌人.MapX, 敌人.MapY, 3);
                //     for (let i = 0; i < 范围目标列表.Count; i++) {
                //         const 范围目标 = 范围目标列表.Actor(i);
                //         if (范围目标 && !范围目标.GetDeath() && !范围目标.IsNPC() && 范围目标.GetHandle() !== 自己.Handle && !范围目标.IsPlayer() && !范围目标.Master) {
                //             // 范围目标.ShowEffectEx2(特效.爆裂火冢, -10, 25, true, 1);
                //             // 直接扣血
                //             const 目标血量 = 范围目标.GetSVar(91);
                //             const 剩余血量 = 智能计算(目标血量, 爆裂范围伤害, 2);
                //             范围目标.SetSVar(91, js_war(剩余血量, '0') < 0 ? '0' : 剩余血量);
                //             攻击飘血(范围目标, 爆裂范围伤害);
                //             血量显示(范围目标);
                //         }
                //     }
                //     敌人.ShowEffectEx2(特效.爆裂火冢, -10, 25, true, 1);
                //     自己.SendCountDownMessage(`【爆裂火冢】触发！`, 0);
                // }
                break;
            }
            case '正义': {
                // 判断怪物类型：1/2 = 普通怪，3/4 = 精英怪，BOSS不做处理
                const 怪物类型: number = 敌人.GetNVar(TAG) % 10;
                const 是普通怪 = (怪物类型 === 1 || 怪物类型 === 2);
                const 是精英怪 = (怪物类型 === 3 || 怪物类型 === 4);

                // 行刑：对普通怪物伤害增加200%，每级提高20%
                // 洗礼：对精英怪物伤害增加100%，每级提高10%
                if (是普通怪) {
                    // 普通怪使用行刑
                    const 等级 = V.行刑等级 || 1;
                    技能攻击 = 智能计算(技能攻击, String(2 + 等级 * 0.2), 3);
                } else if (是精英怪) {
                    // 精英怪使用洗礼
                    const 等级 = V.洗礼等级 || 1;
                    技能攻击 = 智能计算(技能攻击, String(1 + 等级 * 0.1), 3);
                }
                // BOSS不做行刑/洗礼处理

                // 注意：审判和神罚的伤害计算已移动到 ManagerNpc.ts 的 onMonitorDamageEx 中
                // 因为它们是直接对怪物血量进行操作的最终伤害，不需要经过后续的技能加成流程
                break;
            }
            case '不动': {
                // 泰山：主属性加成
                // const 等级 = V.泰山等级 || 1;
                // 技能攻击 = 智能计算(技能攻击, String(1.3 + 等级 * 0.03), 3);
                // break;
            }
        }
    }

    // 第二步：获取技能加成倍率
    let 技能加成倍率 = 1;
    let 技能魔次 = '1';

    const skillConfig = SKILL_CONFIGS.get(技能序号);
    if (skillConfig) {
        const 技能属性 = getSkillAttributes(自己, 技能序号);
        if (技能属性) {
            // 计算技能加成倍率
            const 安全等级 = safeNumber(技能属性.等级);
            技能加成倍率 = skillConfig.基础加成 + 安全等级 * skillConfig.等级加成;
            技能魔次 = 安全字符(技能属性.魔次, '1');

            // 执行特殊效果
            if (skillConfig.hasSpecialEffect && skillConfig.specialEffectHandler) {
                skillConfig.specialEffectHandler(自己, 敌人);
            }
        }
    }

    // 第三步：基础伤害 * 技能加成
    技能攻击 = 智能计算(技能攻击, String(技能加成倍率), 3);

    // 第四步：计算有效魔次（攻击技能魔次 - 生物魔次抵抗）
    let 有效魔次 = 智能计算(技能魔次, 敌人魔次抵抗, 2);
    if (js_war(有效魔次, '1') < 0) {
        有效魔次 = '1'; // 最小为1
    }

    // 第五步：应用魔次加成
    技能攻击 = 智能计算(技能攻击, 有效魔次, 3);

    // 第六步：获取基因阶数并计算 2^基因阶数
    // 根据玩家的基因类型获取对应的阶数
    let 基因阶数 = 0;
    const 基因类型 = V.基因;

    if (基因类型) {
        switch (基因类型) {
            case '狂化':
                基因阶数 = R.狂化阶数 || 0;
                break;
            case '迅疾':
                基因阶数 = R.迅疾阶数 || 0;
                break;
            case '甲壳':
                基因阶数 = R.甲壳阶数 || 0;
                break;
            case '融合':
                基因阶数 = R.融合阶数 || 0;
                break;
            case '念力':
                基因阶数 = R.念力阶数 || 0;
                break;
            case '协作':
                基因阶数 = R.协作阶数 || 0;
                break;
        }
    }

    if (基因阶数 > 0) {
        // 计算 2^基因阶数（使用幂运算）
        const 基因倍率 = Math.pow(2, 基因阶数);
        技能攻击 = 智能计算(技能攻击, String(基因倍率), 3);
    }

    // 第七步：应用伤害加成（基因增加伤害、神器增伤、套装伤害等）
    let 总伤害加成百分比 = 0;

    // 基因增加伤害加成（迅疾）
    if (R.基因增加伤害) {
        总伤害加成百分比 += R.基因增加伤害;
    }

    // 神器增伤加成
    if (R.神器增伤加成 && R.神器增伤加成 !== '0') {
        总伤害加成百分比 += Number(R.神器增伤加成) || 0;
    }

    // 套装伤害加成
    if (R.最终伤害加成) {
        总伤害加成百分比 += R.最终伤害加成;
    }

    // 应用伤害加成（优化：直接计算倍率，减少一次除法）
    if (总伤害加成百分比 > 0) {
        const 伤害加成倍率 = String(1 + 总伤害加成百分比 * 0.01);
        技能攻击 = 智能计算(技能攻击, 伤害加成倍率, 3);
    }

    // 第八步：暴击计算
    let 暴击几率 = 0;
    let 暴击伤害加成 = 0;

    // 优化：直接从R对象获取暴击属性
    暴击几率 = 自己.R.暴击几率 || 0;
    暴击伤害加成 = 自己.R.暴击伤害 || 0;


    // 暴击触发判定（优化：减少除法运算）
    if (暴击几率 > 0 && random(100) < 暴击几率) {
        // 基础暴击倍率2倍 + 额外暴击伤害加成
        const 暴击总倍率 = String(2 + 暴击伤害加成 * 0.01);
        技能攻击 = 智能计算(技能攻击, 暴击总倍率, 3);
        自己.SendCountDownMessage(`【暴击】触发！`, 0);
    }

    // 第九步：地图伤害修正
    const 修正 = 获取地图伤害修正(地图等级);
    if (修正 !== null) {
        技能攻击 = 智能计算(技能攻击, String(修正), 3);
    }

    // GM秒怪功能
    if (V.我要秒怪) {
        return 转大数值('9e200')
    }
    // if (自己.IsAdmin && 技能序号 == 10000) { return 转大数值('1e2') }


    return 技能攻击;
}


function 处理怪物对玩家伤害(自己: TActor, 敌人: TPlayObject): string {
    // 优化：缓存常用属性访问
    const EV = 敌人.V;
    const ER = 敌人.R;

    // 直接获取地图等级
    const 地图等级 = 地图.地图ID取固定星级(敌人.GetMap().MapID);

    // 安全获取怪物的攻击力（SVar(93) = 攻击）
    let 怪物攻击 = 安全数值(自己.GetSVar(93), 基本常量.最小攻击);

    // 高强度地图怪物攻击加成
    if (地图等级 > 20) {
        怪物攻击 = 智能计算(怪物攻击, '10', 3);
    }

    // 安全获取玩家的防御力（玩家使用R.自定属性[168]）
    let 敌人防御 = 安全数值(ER.自定属性?.[168], 基本常量.基础数值);

    if (ER.人王盾开启) {
        敌人防御 = 智能计算(敌人防御, ER.人王盾护盾值, 1);
    }
    // 计算伤害 = 怪物攻击 - 玩家防御
    let 字符最终攻击 = js_war(怪物攻击, 敌人防御) <= 0 ? 基本常量.最小攻击 : 智能计算(怪物攻击, 敌人防御, 2);
    字符最终攻击 = sanitizeDamage(字符最终攻击, 基本常量.最小攻击);

    const 转生减伤 = ER.伤害吸收 / 100
    if (转生减伤 > 0) {
        字符最终攻击 = 智能计算(字符最终攻击, String(1 - 转生减伤), 3);
    }

    // 确保最小伤害
    if (js_war(字符最终攻击, '1') < 0) {
        字符最终攻击 = '1';
    }

    return 字符最终攻击;
}

export function 计算伤害(自己: TActor, 敌人: TActor, 技能序号: number, _伤害倍数?: number): any {
    // 优化：快速路径 - 提前检查合法性
    if (!检查攻击合法性(自己, 敌人)) {
        return 0;
    }

    if (自己.IsPlayer() && 技能序号 < 0) {
        return 0;
    }

    let 最终伤害 = '0';

    // 优化：根据攻击者类型计算伤害
    const 是玩家 = 自己.IsPlayer();

    if (是玩家) {
        最终伤害 = 计算玩家伤害(自己 as TPlayObject, 敌人, 技能序号);
    } else { // 怪物攻击
        if (敌人.IsPlayer()) {
            最终伤害 = 处理怪物对玩家伤害(自己, 敌人 as TPlayObject);
            // 应用玩家受伤被动技能（血气吸纳、铁布衫、人王盾等）
            最终伤害 = 计算受伤被动(敌人 as TPlayObject, 最终伤害);
        }
    }

    // 优化：使用快速检查无效值
    if (!最终伤害 || 最终伤害[0] === 'N' || 最终伤害[0] === 'I') {
        最终伤害 = 基本常量.基础数值;
    }


    // 确保伤害不为负数
    if (js_war(最终伤害, 基本常量.最小攻击) < 0) {
        最终伤害 = 基本常量.基础数值;
    }

    // 优化：伤害提示显示 - 只在需要时计算技能名字
    if (是玩家) {
        const 玩家 = 自己 as TPlayObject;
        if (玩家.V.伤害提示) {
            const 技能名字 = 技能ID转换技能名称(技能序号);
            const 伤害简写 = 大数值整数简写(最终伤害);
            const 玩家名 = 玩家.GetName();
            const 位数 = 最终伤害.length;
            玩家.SendMessage(`【伤害提示】:{S=${玩家名};C=22} 使用 {s=${技能名字};C=22} 攻击目标造成伤害 {S=${伤害简写};C=22} {s=(${位数});c=9} 位`, 2);
        }
    }


    // 伤害应用和死亡判定
    if (!CheckBuffGroupID(敌人, 1011)) { // 目标不处于无敌状态
        // 直接获取敌人血量
        const 敌人血量 = 安全数值(敌人.GetSVar(91), 基本常量.最小攻击);
        let 剩余血量 = 智能计算(敌人血量, 最终伤害, 2);

        // 确保血量不为负数
        剩余血量 = js_war(剩余血量, 基本常量.基础数值) < 0 ? 基本常量.基础数值 : 剩余血量;

        // 应用伤害效果
        攻击飘血(敌人, 最终伤害);
        敌人.SetSVar(91, 剩余血量);
        血量显示(敌人);

        // 死亡判定
        if (js_war(剩余血量, 基本常量.基础数值) <= 0) {
            敌人.GoDie(自己, 自己);

            // ✅ 使用击杀生物函数处理掉落、杀怪数量、击杀计数、鞭尸等（统一处理）
            if (是玩家 && !敌人.IsPlayer() && !敌人.Master) {
                击杀生物(自己 as TPlayObject, 敌人, 1);
            }

            // 清理怪物
            if (!敌人.IsPlayer()) {
                try {
                    const 怪物Handle字符串 = String(敌人.Handle);
                    if (GameLib.R?.怪物信息?.[怪物Handle字符串]) {
                        delete GameLib.R.怪物信息[怪物Handle字符串];
                    }
                } catch { }
                敌人.MakeGhost();
            }
        }
    }

    return;
}


/**
 * 击杀生物函数 - 用于外部调用（如技能、道具等）
 * 
 * @param Player 玩家对象
 * @param 敌人 目标生物
 * @param 执行次数 基础执行次数（默认1次）
 * @returns 实际执行次数（包含鞭尸加成）
 * 
 * 说明：
 * - 基础执行次数 + 鞭尸次数 = 实际执行次数
 * - 例如：执行次数=1，鞭尸次数=1，则实际执行2次
 * - 鞭尸会额外调用 GoDie 并设置不复活标记
 */
export function 击杀生物(Player: TPlayObject, 敌人: TActor, 执行次数: number = 1): number {
    // 基础检查
    if (!Player || !敌人 || !Player.IsPlayer()) return 0;
    if (敌人.IsPlayer() || 敌人.Master) return 0;
    if (敌人.GetSVar(原始名字) === '全民boss') return 0;

    // 计算实际执行次数 = 基础次数 + 鞭尸次数
    let 实际执行次数 = 执行次数;
    let 触发鞭尸 = false;

    // 鞭尸加成：如果触发鞭尸，额外增加鞭尸次数
    if (random(100) < (Player.R.鞭尸几率 || 0)) {
        触发鞭尸 = true;
        实际执行次数 += (Player.R.最终鞭尸次数 || 0);
        // 设置不复活标记
        敌人.SetNVar(怪物鞭尸不复活, 1);
        if (Player.V.鞭尸提示) {
            Player.SendCountDownMessage(`【鞭尸】触发！太残暴了!!目标怪物被你揉虐了 {S=${实际执行次数};C=191} 次`, 0);
        }
    }

    // 执行掉落和其他计算
    for (let i = 0; i < 实际执行次数; i++) {
        执行掉落(Player, 敌人);

        // 累加杀怪数量
        坐骑升级(Player)
        Player.V.杀怪数量 = (Player.V.杀怪数量 || 0) + 1;

        // 增加击杀计数（享受鞭尸加成）
        const 地图ID = 敌人.Map?.MapName;
        if (地图ID) {
            增加击杀计数(地图ID);
        }

        // 鞭尸额外 GoDie（第一次已在外部调用，这里只处理额外次数）
        if (触发鞭尸 && i > 0) {
            敌人.GoDie(Player, Player);
        }

        // TODO: 后续可在此添加其他计算
        // 例如：经验、积分、任务进度等
    }

    // 特殊BOSS/大陆BOSS死亡触发（只触发一次，不受鞭尸影响）
    const 地图ID = 敌人.Map?.MapName;
    const 怪物TAG = 敌人.GetNVar(TAG) % 10;
    if (地图ID) {
        if (怪物TAG === 7) {
            特殊BOSS死亡(地图ID);
        } else if (怪物TAG === 6) {
            大陆BOSS死亡(地图ID);
        }
    }

    return 实际执行次数;
}

export function 坐骑升级(Player: TPlayObject) {
    // 检查玩家坐骑位装备
    const 坐骑装备 = Player.Mount;
    if (!坐骑装备) return;

    // 根据名字获取等级
    const 坐骑名字 = 坐骑装备.DisplayName;
    const 等级匹配 = 坐骑名字.match(/『(\d+)阶』/);
    if (!等级匹配) return;

    const 当前等级 = parseInt(等级匹配[1]);
    if (当前等级 >= 100) return; // 最高等级100级

    // 获取OUTWAY信息
    const 当前杀怪数量 = Player.V.杀怪数量 || 0;
    // const 需要升级数量 = 坐骑装备.GetOutWay3(4);

    // 计算需要升级的数量
    let 升级所需数量 = 0;
    if (当前等级 < 10) {
        升级所需数量 = 2 * 500;
    } else if (当前等级 < 30) {
        升级所需数量 = 2 * 1000;
    } else if (当前等级 < 50) {
        升级所需数量 = 2 * 2000;
    } else if (当前等级 < 70) {
        升级所需数量 = 2 * 3000;
    } else if (当前等级 < 90) {
        升级所需数量 = 2 * 4000;
    } else if (当前等级 < 100) {
        升级所需数量 = 2 * 5000;
    }
    坐骑装备.SetOutWay1(40, 4);
    坐骑装备.SetOutWay2(40, 当前杀怪数量);
    坐骑装备.SetOutWay3(40, 升级所需数量);
    Player.UpdateItem(坐骑装备);

    // 检查是否可以升级
    if (当前杀怪数量 >= 升级所需数量) {
        const 新等级 = 当前等级 + 1;

        // 更新坐骑名字
        const 新名字 = 坐骑名字.replace(/『\d+阶』/, `『${新等级}阶』`);
        坐骑装备.Rename(新名字);

        // 重置杀怪数量
        Player.V.杀怪数量 = 0;

        // 赋予属性加成 (OUTWAY1 1-6位置)
        const 属性ID列表 = [116, 117, 118, 119, 120, 121]; // 攻击、魔法、道术、刺术、箭术、武术百分比
        const 属性值 = 新等级 * 5;

        for (let i = 0; i < 属性ID列表.length; i++) {
            坐骑装备.SetOutWay1(i, 属性ID列表[i]);
            坐骑装备.SetOutWay2(i, 属性值);
        }

        // 设置OUTWAY2和OUTWAY3
        坐骑装备.SetOutWay1(40, 4);
        坐骑装备.SetOutWay2(40, 当前杀怪数量);
        坐骑装备.SetOutWay3(40, 升级所需数量);

        坐骑装备.SetBind(true);
        坐骑装备.SetNeverDrop(true);
        坐骑装备.State.SetNoDrop(true);
        Player.UpdateItem(坐骑装备);


        // 存储到JSON（用于属性统计）
        const 装备属性记录 = {
            职业属性_职业: 属性ID列表,
            职业属性_属性: 属性ID列表.map(() => String(属性值))
        };
        坐骑装备.SetCustomDesc(JSON.stringify(装备属性记录));
        装备属性统计(Player)

        // 发送升级消息
        Player.SendMessage(`【坐骑升级】恭喜！坐骑升级至${新等级}阶！`, 2);
        Player.SendCountDownMessage(`【坐骑升级】${新名字} 升级成功！`, 0);
    }

}
